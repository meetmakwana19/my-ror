### V37 - Query methods : Conditions 

1. 
```
Subject.where(conditions)
```

    1. These conditions can be expressed in 
       1. Strings ( `"name="test" AND visbile=true"` )
       2. Arrays
       3. Hash forms
2. String conditions :
   1. FLexible due to it's form of raw SQL.
   2. Use carefull coz of SQL Injection attack when the value is passed dynamically like `"name='#{@name}'"` where @name can be --hacker code--.
   3. So use static strings as conditions
3. Array conditions :
   1. Can be used for dynamic values
   2. Safe from SQL Injecton/
   3. eg. `["name=? AND visible=true", "test"]
4. Hash conditions 
   1. `{:name =. "Test", :visible => true}`
   2. Each key-value pair is joint automatically with AND.
   3. Safe from SQL Injection.
5. Conditions return an ActiveRelation and are chained.
6. Executing HAsh condition
```
subjects = Subject.where(:visible => true)
subjects = Subject.where(:visible => true, :position => 1)
```
chainable condition in hash
```
subjects = Subject.where(:visible => true).where(:position => 1)
```
```
irb(main):003:0> subjects.class
=> Subject::ActiveRecord_Relation
irb(main):004:0> subjects.to_sql
=> "SELECT `subjects`.* FROM `subjects` WHERE `subjects`.`visible` = TRUE"
```
7. String conditions
```
subjects = Subject.where("visible = true")
```
8. Array condition
```
subjects = Subject.where(["visible = ?", "false"])
```

---

### V38 - Query methods - Order, limit and offset

- To find exactly the records that we want
- These query methods all are chainable

```
order(string)
limit(integer)
offset(integer)
```

1. order arguement
   1. 
   ```
   order(position)

   order("position")

   order(:position => :asc)

   order("position ASC")

   order(:position => :desc)

   order("position DESC")
   ```
   2. When working with multipe tables which can be joined, do order SQL table disam0biguation
      1. Required when joined tables have common column names 
      2. ```order("subjects.created_at ASC")```
   3. Trying queries on rails console
   ```
   subjects = Subject.order(:position)
   ```
   4. 
   ```
   subjects = Subject.order("position ASC")
   ```
   5. 
   ```
   subjects = Subject.order("position DESC")
   ```
2. limit returns an array and if we want object then we can use first or last by chaining it 
```
s = Subject.limit(2)
```
```
s = Subject.limit(2).first
```
3. offset skip the number of records and returns the remaining ones.
```
 s = Subject.offset(1)
```
THis will skip the first record and return an array consisting of records from index 2
O/p:
```
=> #<ActiveRecord::Relation [#<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">, #<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">]>
```
   1. Can also use limit with it
   ```
   s = Subjects.offset(1).limit(1)
   ```
4. Trying all of them together
```
subjects = Subject.where(:visible => true).order("position ASC").limit(1).offset(1)
```
O/p :
```
=> #<ActiveRecord::Relation [#<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">]>
```

- ActiveRelation will take all the things we've asked for and try to compile them into one query 

---

### V39 - Named scopes

- We've been using the buit-in methods for free provided by ActiveRecord and ActiveRelation inherited from ActiveRecordBase for CRUD, finding, and other tasks.
- We can build our own query combined with the built-in methods and save it in our model as **Named scope**.
- **A good way to take alot of complex logic for query and store in a model to call it again as a method**
1. Named scope assign a name to an ActiveRelation query and save it in the model.
2. Accepts parameters
3. Rails 5 requires **lambda syntax** 
4. Naming a scope :
   1. active is the name of the scope, lambda can be also written with -> and where is the normal built-in query method.
   ```
   scope :active, lambda {where(: active => true)}

   scope :active, -> {where(:active => true)}

   ```
   2. Function a=can be defined in a similar way
   ```
   def self.active
      where(:active => true)
   end
   ```
5. To call a scope, use name of the Class(i.e. Student) and name if the scope(i.e. active)
```
Student.active
```
6. Arguements in Scope. Passing the variable using 2 pipes 
```
scope: with content_type, lambda{ |ctype| where(:content_type => ctype)
}

def self.with_content_type(ctype) 
   where(:content_type => ctype) 
end

Section.with_content_type('html')

```
7. Lambda is required to pass an arguement as the parameter will be evaluated only when called and not when defined.
8. Scopes are chainable
9. Wrote `scope`s in the model file `subject.rb`
10. Executed those scopes one by one on the rails console
```
Subject.visible
```
o/p:
```
Subject Load (0.6ms)  SELECT  `subjects`.* FROM `subjects` WHERE `subjects`.`visible` = TRUE LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">, #<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">]>
```
```
Subject.invisible
```
o/p:
```
Subject Load (0.6ms)  SELECT  `subjects`.* FROM `subjects` WHERE `subjects`.`visible` = FALSE LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">]>
```
```
Subject.sorted
```
o/p:
```
Subject Load (0.4ms)  SELECT  `subjects`.* FROM `subjects` ORDER BY position ASC LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">, #<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">, #<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">]>
```
```
Subject.newest_first
```
o/p:
```
Subject Load (0.6ms)  SELECT  `subjects`.* FROM `subjects` ORDER BY created_at DESC LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">, #<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">, #<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">]>
```
```
Subject.search("Initial")
```
o/p:
```
Subject Load (6.5ms)  SELECT  `subjects`.* FROM `subjects` WHERE (name LIKE '%Initial%') LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">]>
```

---

### V40 - Relationship types 

1. Related different models
2. ActiveRecord provides "Association" which allows to define these resltionhips.

- Relational DB Associations :
1. One to one 
2. One to many
3. Many to many (Joint tables used)

- ActiveRecord Associations :
1. One to one 
   1. Classroom has_one :teacher
   2. Classroom belongs_to :teacher
2. One to many
   1. Teacher has_many :courses
   2. A course belongs_to :teacher
3. Many to many 
   1. Course has_and_belongs_to_many :students 
   2. Student has_and_belongs_to_many :courses 
