### V37 - Query methods : Conditions 

1. 
```
Subject.where(conditions)
```

    1. These conditions can be expressed in 
       1. Strings ( `"name="test" AND visbile=true"` )
       2. Arrays
       3. Hash forms
2. String conditions :
   1. FLexible due to it's form of raw SQL.
   2. Use carefull coz of SQL Injection attack when the value is passed dynamically like `"name='#{@name}'"` where @name can be --hacker code--.
   3. So use static strings as conditions
3. Array conditions :
   1. Can be used for dynamic values
   2. Safe from SQL Injecton/
   3. eg. `["name=? AND visible=true", "test"]
4. Hash conditions 
   1. `{:name =. "Test", :visible => true}`
   2. Each key-value pair is joint automatically with AND.
   3. Safe from SQL Injection.
5. Conditions return an ActiveRelation and are chained.
6. Executing HAsh condition
```
subjects = Subject.where(:visible => true)
subjects = Subject.where(:visible => true, :position => 1)
```
chainable condition in hash
```
subjects = Subject.where(:visible => true).where(:position => 1)
```
```
irb(main):003:0> subjects.class
=> Subject::ActiveRecord_Relation
irb(main):004:0> subjects.to_sql
=> "SELECT `subjects`.* FROM `subjects` WHERE `subjects`.`visible` = TRUE"
```
7. String conditions
```
subjects = Subject.where("visible = true")
```
8. Array condition
```
subjects = Subject.where(["visible = ?", "false"])
```

---

### V38 - Query methods - Order, limit and offset

- To find exactly the records that we want
- These query methods all are chainable

```
order(string)
limit(integer)
offset(integer)
```

1. order arguement
   1. 
   ```
   order(position)

   order("position")

   order(:position => :asc)

   order("position ASC")

   order(:position => :desc)

   order("position DESC")
   ```
   2. When working with multipe tables which can be joined, do order SQL table disam0biguation
      1. Required when joined tables have common column names 
      2. ```order("subjects.created_at ASC")```
   3. Trying queries on rails console
   ```
   subjects = Subject.order(:position)
   ```
   4. 
   ```
   subjects = Subject.order("position ASC")
   ```
   5. 
   ```
   subjects = Subject.order("position DESC")
   ```
2. limit returns an array and if we want object then we can use first or last by chaining it 
```
s = Subject.limit(2)
```
```
s = Subject.limit(2).first
```
3. offset skip the number of records and returns the remaining ones.
```
 s = Subject.offset(1)
```
THis will skip the first record and return an array consisting of records from index 2
O/p:
```
=> #<ActiveRecord::Relation [#<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">, #<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">]>
```
   1. Can also use limit with it
   ```
   s = Subjects.offset(1).limit(1)
   ```
4. Trying all of them together
```
subjects = Subject.where(:visible => true).order("position ASC").limit(1).offset(1)
```
O/p :
```
=> #<ActiveRecord::Relation [#<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">]>
```

- ActiveRelation will take all the things we've asked for and try to compile them into one query 

---

### V39 - Named scopes

- We've been using the buit-in methods for free provided by ActiveRecord and ActiveRelation inherited from ActiveRecordBase for CRUD, finding, and other tasks.
- We can build our own query combined with the built-in methods and save it in our model as **Named scope**.
- **A good way to take alot of complex logic for query and store in a model to call it again as a method**
1. Named scope assign a name to an ActiveRelation query and save it in the model.
2. Accepts parameters
3. Rails 5 requires **lambda syntax** 
4. Naming a scope :
   1. active is the name of the scope, lambda can be also written with -> and where is the normal built-in query method.
   ```
   scope :active, lambda {where(: active => true)}

   scope :active, -> {where(:active => true)}

   ```
   2. Function can be defined in a similar way
   ```
   def self.active
      where(:active => true)
   end
   ```
5. To call a scope, use name of the Class(i.e. Student) and name if the scope(i.e. active)
```
Student.active
```
6. Arguements in Scope. Passing the variable using 2 pipes 
```
scope: with content_type, lambda{ |ctype| where(:content_type => ctype)
}

def self.with_content_type(ctype) 
   where(:content_type => ctype) 
end

Section.with_content_type('html')

```
7. Lambda is required to pass an arguement as the parameter will be evaluated only when called and not when defined.
8. Scopes are chainable
9. Wrote `scope`s in the model file `subject.rb`
10. Executed those scopes one by one on the rails console
```
Subject.visible
```
o/p:
```
Subject Load (0.6ms)  SELECT  `subjects`.* FROM `subjects` WHERE `subjects`.`visible` = TRUE LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">, #<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">]>
```
```
Subject.invisible
```
o/p:
```
Subject Load (0.6ms)  SELECT  `subjects`.* FROM `subjects` WHERE `subjects`.`visible` = FALSE LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">]>
```
```
Subject.sorted
```
o/p:
```
Subject Load (0.4ms)  SELECT  `subjects`.* FROM `subjects` ORDER BY position ASC LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">, #<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">, #<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">]>
```
```
Subject.newest_first
```
o/p:
```
Subject Load (0.6ms)  SELECT  `subjects`.* FROM `subjects` ORDER BY created_at DESC LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 4, name: "Third subject", position: 4, visible: false, created_at: "2022-09-20 16:37:19", updated_at: "2022-09-21 10:50:03">, #<Subject id: 2, name: "Next subject", position: 2, visible: true, created_at: "2022-09-20 14:47:48", updated_at: "2022-09-20 15:23:24">, #<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">]>
```
```
Subject.search("Initial")
```
o/p:
```
Subject Load (6.5ms)  SELECT  `subjects`.* FROM `subjects` WHERE (name LIKE '%Initial%') LIMIT 11
=> #<ActiveRecord::Relation [#<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">]>
```

---

### V40 - Relationship types 

1. Related different models
2. ActiveRecord provides "Association" which allows to define these resltionhips.

- Relational DB Associations :
1. One to one 
2. One to many
3. Many to many (Joint tables used)

- ActiveRecord Associations :
1. One to one 
   1. Classroom has_one :teacher
   2. Classroom belongs_to :teacher
2. One to many
   1. Teacher has_many :courses
   2. A course belongs_to :teacher
3. Many to many 
   1. Course has_and_belongs_to_many :students 
   2. Student has_and_belongs_to_many :courses 

---

### V41 - One to one Associations

1. Class with `belongs_to` needs to have foreign key.
2. Always define both sides of the relationship 
3. Added 1:1 Association in subject and page model files.
4. In rails console,
```
first_page = Page.new(:name => "First page", :permalink => "first", :position => 1)
```
```
subject.page = first_page
```
o/p:
```
  Page Create (0.5ms)  INSERT INTO `pages` (`subject_id`, `name`, `permalink`, `position`, `created_at`, `updated_at`) VALUES (1, 'First page', 'first', 1, '2022-09-21 14:48:51', '2022-09-21 14:48:51')
   (9.6ms)  COMMIT
```
```
irb(main):008:0> subject.page
=> #<Page id: 1, subject_id: 1, name: "First page", permalink: "first", position: 1, visible: false, created_at: "2022-09-21 14:48:51", updated_at: "2022-09-21 14:48:51">
irb(main):009:0> first_page.subject_id
=> 1
```
When we do associations, it saves the record in DB by creating pk and fk.
```
irb(main):010:0> first_page.new_record?
=> false
```
5. To remove the association
```
subject.page = nil
```
6. To delete the entry of other table by removing association
```
subject.page.destroy
```
o/p:
```
   (0.4ms)  BEGIN
  Page Destroy (0.6ms)  DELETE FROM `pages` WHERE `pages`.`id` = 1
   (8.9ms)  COMMIT
=> #<Page id: 1, subject_id: 1, name: "First page", permalink: "first", position: 1, visible: false, created_at: "2022-09-21 14:48:51", updated_at: "2022-09-21 14:48:51">
```
```
Page.all
```
will give an empty array

---

### V42 - One to many associations

1. Plural relationship names
2. Returns an array of objects instead of a single object.
3. Our simple_cms project is going to make good use of this
4. To add a page we use append operator
```
subject.pages << page
```
5. `has_many` Methods
```
subject.pages

subject.pages << page

subject.pages = [page, page, page] 

subject.pages.delete(page) 

subject.pages.destroy(page)

subject.pages.clear

subject.pages.empty?

subject.pages.size
```
6. Updating the 1:1 association in subject.rb to `has_many`.
7. Starting rails console.
8. 
```
subject = Subject.find(1)
```

9. s
```
subject.page
```
wont work because the 1:1 association has been changed to 1:m in the subject model.
SO use,
```
subject.pages
```
10. 
```
first_page = Page.new(:name => "FIrst page", :permalink => "first", :position => 1) 
```
11. Append the first_page 
```
subject.pages << first_page
```
o/p:
```
Page Create (1.0ms)  INSERT INTO `pages` (`subject_id`, `name`, `permalink`, `position`, `created_at`, `updated_at`) VALUES (1, 'FIrst page', 'first', 1, '2022-09-21 16:32:45', '2022-09-21 16:32:45')
   (3.8ms)  COMMIT
  Page Load (1.1ms)  SELECT  `pages`.* FROM `pages` WHERE `pages`.`subject_id` = 1 LIMIT 11
=> #<ActiveRecord::Associations::CollectionProxy [#<Page id: 2, subject_id: 1, name: "FIrst page", permalink: "first", position: 1, visible: false, created_at: "2022-09-21 16:32:45", updated_at: "2022-09-21 16:32:45">]>
```
12. The page got saved into the DB
```
irb(main):012:0> first_page.new_record?
=> false
```
13. Creating 2nd page
```
second_page = Page.new(:name => "Second page", :permalink => "second", :position => 2)
```
14. Add that page to  the subject
```
subject.pages << second_page
```
o/p:
```
   (0.4ms)  BEGIN
  Page Create (0.7ms)  INSERT INTO `pages` (`subject_id`, `name`, `permalink`, `position`, `created_at`, `updated_at`) VALUES (1, 'Second page', 'second', 2, '2022-09-21 16:37:26', '2022-09-21 16:37:26')
   (9.9ms)  COMMIT
  Page Load (0.7ms)  SELECT  `pages`.* FROM `pages` WHERE `pages`.`subject_id` = 1 LIMIT 11
=> #<ActiveRecord::Associations::CollectionProxy [#<Page id: 2, subject_id: 1, name: "FIrst page", permalink: "first", position: 1, visible: false, created_at: "2022-09-21 16:32:45", updated_at: "2022-09-21 16:32:45">, #<Page id: 3, subject_id: 1, name: "Second page", permalink: "second", position: 2, visible: false, created_at: "2022-09-21 16:37:26", updated_at: "2022-09-21 16:37:26">]>
irb(main):016:0> 
```
15. Size gives the nuber of objects in the array
```
subject.pages.size
```
```
   (5.8ms)  SELECT COUNT(*) FROM `pages` WHERE `pages`.`subject_id` = 1
=> 2
```

16. Count gives the number of records in the table.
```
irb(main):004:0> subject.pages.count
   (0.5ms)  SELECT COUNT(*) FROM `pages` WHERE `pages`.`subject_id` = 1
=> 2
```
17. 
```
subject.pages.empty?
```
```
  Page Exists (0.4ms)  SELECT  1 AS one FROM `pages` WHERE `pages`.`subject_id` = 1 LIMIT 1
=> false
```

18. Removing a page from the subject
```
subject.pages.delete(first_page)
```
o/p:
```
 Page Update All (0.6ms)  UPDATE `pages` SET `pages`.`subject_id` = NULL WHERE `pages`.`subject_id` = 1 AND `pages`.`id` = 2
   (4.5ms)  COMMIT
=> [#<Page id: 2, subject_id: 1, name: "FIrst page", permalink: "first", position: 1, visible: false, created_at: "2022-09-21 16:32:45", updated_at: "2022-09-21 16:32:45">]
```
and the table in mysql got affected successfully and removed the association with subject 
```
mysql> select * from pages;
| id | subject_id | name        | permalink | position |  
|  2 |       NULL | FIrst page  | first     |        1 |       
|  3 |          1 | Second page | second    |        2 |       
+----+------------+-------------+-----------+----------+
```
19. We can get subject info too from the page
```
first_page.subject
```
```
  Subject Load (0.6ms)  SELECT  `subjects`.* FROM `subjects` WHERE `subjects`.`id` = 1 LIMIT 1
=> #<Subject id: 1, name: "Initial subject", position: 1, visible: true, created_at: "2022-09-20 14:39:08", updated_at: "2022-09-20 15:09:22">
```
20. Page-section
- Page has_many :sections
- Section belongs_to :page

---

### 43 - `belongs_to` presence validation

1. Introduced in Rails 5.0\
2. `belongs_to` relationship is not options by default
3. ActiveRecord adds a validation for the object presence.
4. Validation is to check the data before it has been saved to the DB.
5. Trying on rails console now.
```
page = Page.new(:name => "No subject assigned")
```
6. Upon saving 
```
page.save
```
It wont be saved 
```
(0.3ms)  ROLLBACK
=> false
```
To check error type
```
page.errors.full_messages
```
o/p:
```
=> ["Subject must exist"]
```
7. One of the way to overcome this error is by making subject not necessary by writing `belongs_to` optional to be true in the `page.rb`
   1. Carefull while doing this as the optional false is for the protection as no orphan pages should go into DB without belonging to a subject.

---

### V44 : Many to many associations

1. Requires a join table.
2. Needs 2 foreign keys that point to 2 diff tables on each side of the join. 
   1. Index on both foreign keys to look for them easily.
3. NO primary key on the join table as it is only seen as a link between to relating tables.
4. ActiveRecord adds instance methods to the class upon defining these associations.
5. Joint table naming convention in rails 
   1. PLural tables names 
   2. ALPHABETICAL ORDER
   3. For Project and Collaborator tables, join table will be "collaborators_projects"
   4. For AdminUser and Page, admin_users_pages.
6. Creating a new migration 
```
rails generate migration CreateAdminUsersPagesJoin
```
Automatically creates a `create_table` method as Create keyword is used in the name of the migration.
7. Added code in the up and down method of the migration file and ran the migratio `rails db:migrate"
8. Created a model `rails generate model AdminUser` and then ran migrations. 
9. Using rails console
```
AdminUser.all
```
returns an empty array as nothing we've added 
```
=> #<ActiveRecord::Relation []>
```
10. make a page object
```
page = Page.find(2)
```
```
page.admin_users
```
returns empty array for now
```
dminUser Load (0.4ms)  SELECT  `admin_users`.* FROM `admin_users` INNER JOIN `admin_users_pages` ON `admin_users`.`id` = `admin_users_pages`.`admin_user_id` WHERE `admin_users_pages`.`page_id` = 2 LIMIT 11
=> #<ActiveRecord::Associations::CollectionProxy []>
```
11. 
```
me = AdminUser.create(:first_name => "Meet", :lastname => "Makwana", :username => "meetmakzz")
```
To add that created user to the page
```
page.admin_users << me
```