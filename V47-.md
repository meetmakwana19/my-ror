### V47 - CRUD

1. Create
   1. `new` - Display new record form. /subjects/new
   2. `create` - Process new record form. /subjects/create
2. Read 
   1. `index` - List records. /subjects/create
   2. `show` - Display a single record. /subjects/show/:id
3. Update
   1. `edit` - Display edit record form. /subjects/edit/:id
   2. `update` - Process edit record form. /subjects/update/:id
4. Delete
   1. `delete` -Display delete record form. /subjects/delete/:id
   2. `destroy` - Process delete record form. /subjects/destroy/:id

- Dividing the controller by Separate controllers 
  - SubjectsController, PagesController,  SectionsController.
  - One controller per model
  - Use plural names

1. Generating a new model with action views in the command itself.
```
rails generate controller Subjects index show new edit delete
```
2. Adding another extra CRUD action methods in the subjects_controller.rb

---
### V48 - REST (Representational State Transfer)

1. Do not perform procedures 
2. Perform state trasformations upon resources.

REST Paradigm Requirements

1. Organize code into resources

   Encourages one controller for each model

2. Learn HTTP verbs(GET, POST, PATCH, DELETE) for working with resources

   Determine which CRUD actions are suited for each verb

3. Map a new URL syntax to controller actions

   Change Rails routes

4. Modify existing links and forms to use new URL syntax.    

   Use resourceful URL helpers

- Different HTML versions have varying number of support for REST. So rails have a work around for it to work REST universally.
  - It fakes a true REST request by adding a hidden field called `_method` to the form and uses POST for that form.

---

### V49 - Resourcefull routes 

1. URL accessed by rails is different in REST which are called as resourceful routes used to access the basic CRUD actions in our controller.
2. Rails default
3. Optimized for rais 
4. Simple, consistent and organized structure
5. Improves application security.
6. Most proffessional developers use them.
7. Saves alot of typing
8. Shortcut to create a resourceful route in rails 
```
resources :subjects
```
8. Rails doesnt include all 8 of the REST actions. DELETE is not by default included ny rails. As it's optional to view the info before deleting it like a confirmation pop up.
9. Can limit the resources to be accessed by the routes by adding `:except =>` or `:only =>` to the definition.
10. Can add additional resourceful routes by adding `member` and `collection` to the definition. 
    1.  `member` routes operate on a member of the resource. They expect to recieve a record id in the URL. eg. EDIT & UPDATE Are buil-in member routes.
    2.  `collection` routes operate as a whole. They do not expect a record ID In the URL. eg. INDEX, NEW, CREATE
11. It is common to operate both on resourceful and simple routes. Like a simple route to just show an about page of static HTML not requiring any resources.
12. Added resourceful route for subjects on the routes.rb
13. Command to see all the routes of our rails app.
```
rails routes
```

---

### V50 - Resourceful URL helpers 

1. Instead of writing a hash for route like `{:controller => 'subjects', :action => "show", id => 3}` we can write `subject_path(3)`.
2. Almost all of the URL helpers use subject as singular as they would be dealing with one at a time.
   1. `index` and `create` has plural helpers as they are `collection` routes.
   2. There are only 2 variatioons.
      1. `subjects_path` plural
      2. `subject_path(:id)` singular
         1. For other cases, just put new, edit, delete in start of it.
   
| HTTP Verb | URL                  | Action  | URL Helper               |
| --------- | -------------------- | ------- | ------------------------ |
| GET       | /subjects            | index   | subjects_path            |
| GET       | /subjects/:id        | show    | subject_path(:id)        |
| GET       | /subjects/new        | new     | new_subject_path         |
| POST      | /subjects            | create  | subjects_path            |
| GET       | /subjects/:id/edit   | edit    | edit_subject_path(:id)   |
| PATCH     | /subjects/:id        | update  | subject_path(id)         |
| GET       | /subjects/:id/delete | delete  | delete_subject_path(:id) |
| DELETE    | /subjects/:id        | destroy | subject_path(id)         |
---
3. URL helpers help to genrate correct URL.
```
<%= link_to('All Subjects', subjects_path) %>

<%= link_to('All Subjects', subjects_path(: page => 3) %>

<%= link_to('Show Subject', subject_path(@subject.id)) %>

<%= link_to('Show Subject', subject_path(@subject.id, : format => 'verbose')) %>

<%= link_to('Edit Subject', edit_subject_path(@subject.id)) %>
```

---

### V51 - Read action : INDEX(list records)

1. Wrote code in index definiton of the subjects_controller.rb
2. Wrote html code in the view template of `index.html.erb`
3. Tried http://localhost:3000/subjects as in th routes.rb we had written just "subjects" while defining the restful route.
4. This is the first time we completed full cycle of running through MVC Architecture.
```Started GET "/subjects" for ::1 at 2022-09-24 21:23:27 +0530
Processing by SubjectsController#index as HTML
  Rendering subjects/index.html.erb within layouts/application
  Subject Load (0.4ms)  SELECT `subjects`.* FROM `subjects` ORDER BY position ASC
  ↳ app/views/subjects/index.html.erb:18
   (0.8ms)  SELECT COUNT(*) FROM `pages` WHERE `pages`.`subject_id` = 1
  ↳ app/views/subjects/index.html.erb:23
   (0.5ms)  SELECT COUNT(*) FROM `pages` WHERE `pages`.`subject_id` = 2
  ↳ app/views/subjects/index.html.erb:23
   (0.4ms)  SELECT COUNT(*) FROM `pages` WHERE `pages`.`subject_id` = 4
  ↳ app/views/subjects/index.html.erb:23
  Rendered subjects/index.html.erb within layouts/application (6.7ms)
Completed 200 OK in 24ms (Views: 20.8ms | ActiveRecord: 2.0ms)
```
- **VIEWS** - looking at the /subjects in the URL, rails determined that the resoucefull route needs to be passed to the subjects_controller
- **CONTROLLER** - SubjectsController rendered the index view as the def index method had a code in it.
- **MODEL** - The instance variale(which the view template has access to) created in the SubjectsController indicated `sorted` scope of the subject.rb model. Using the `Subject.` model defined in the controller, it returned the array of Subjects from model in that `sorted` manner.

---
### V52 - Read action : SHOW(Display a single record)

1. Used resourceful route to show the subject in index.html.erb
2. Made an instance variable subject in the subjects_controller
3. Added html code in the view template of show.html.erb

---
### 53 - Form basics

1. Anything written with helpers of rails can also be written in HTML.
2. Forms are POST request and butoons are GET request in HTML.
3. POST parameters in the controller are accessed the same the GET parameters are accessed. Like `params[:key]`
```
params[:name]
params[:position]
params[:visible]
```
4. GET and POST parameters are combined together in rails.
5. If we want to use these parameters to construct a subject then do it like :
```
subject = Subject.new({
   :name => params[:name],
   :position => params[:position],
   :visible => params[:visible]
})
```
But this can get tidious if we had 40 diff parameters in the form then would have to write all of them one by one in the code. So use form arrays
6. **Form Arrays** in HTML - Array of parameters 
```
params[:subject][:name]
params[:subject][:position]
params[:subject][:visible]
```
Now all of these params can be accessed together just by typing 
```
params[:subject]
instead of the hash
{:name => "xyz", :position => '1', :visible => '1'}
```
7. So to create a new subject, simply do 
```
subject = Subject.new(params[:subject])
```

---
**Rails `form_for` helper :**

1. Arguement it accepts is - an object.
2. It'll use a form builder object `f` which is a local code block variable. SO `f` knows about the @subject object
3. This `f` object knows whether the subject object is the saved object or not. If saved then it knows to perform edit action and not then new action. And then adjusts the form accordingly. Also it can populate the existing object values as the parameters.
4. Thereform this will generate a smart dynamic form for us.

---
### V54 - Create Action : `NEW` (displays new record form)

1. Writing the URL for "Add new subject" in the `link_to` tag in `index.html.erb`. 
2. Wrote form_for code in `new.html.erb`.
3. Gave instance variable subject in the `new` def of the subjects_controller

---
### V55 - Create Action : `CREATE` (process new form record via POST)

Create Form Processing

• Instantiate a new object using form parameters

• Save the object

• If save succeeds, redirect to the index action

• If save fails, redisplay the form so user can fix problems

1. Did the above 4 steps in the def create method in the subjects_controller
2. Ran on the browser and tried submitting the form
3. Got error of `ForbiddenAttributesError` on the line `    @subject = Subject.new(params[:subject])`
4. It ran right into rails security feature which is good. Need to learn how to make good use of this feature.
5. Will need to learn mass assignments and strong parameters.

---
### V56 - Strong parameters

**`Mass Assignment`**

• Rails term for passing a hash of values to an object to be assigned as attributes.
- Mass assignment means to dump the values into object using the hash to assign attributes.
```
Subject.new(params[:subject])

Subject.create(params[:subject])

@subject.update_attributes (params[:subject])
```
new, create and update methods are primary methods to use mass assignments.

A **Hash** is a dictionary-like collection of unique keys and their values. Also called associative arrays, they are similar to Arrays, but where an Array uses integers as its index, a Hash allows you to use any object type. [Ref](https://ruby-doc.org/core-2.5.1/Hash.html#:~:text=A%20Hash%20is%20a%20dictionary,the%20corresponding%20keys%20were%20inserted.)

- Unfortunately this convenience allows a major security issue.
- For example, a hacker can pass more attritubes than necessary by filling out extra fields in the form, making a scope to hack into the rails system due to mass assignment of all the attributes. This mass assignment to the object can cause security issues.
- To prevent this, **Mass Assignment Filtering** can be done.

---
Mass Assignment Filtering :-

* Rails v1-2: could do blacklisting of attributes. To not allow some of them. Was an optional feature.

* Rails v3: whitelisting of attributes. Delcare all allowed attributes. Can turn it on/off. 

All these happened at model level making things difficult for public vs admin submitting the form.

The above problems were solved in v4-5.

* Rails v4-5: strong parameters
  * They cant be turned off easily. They're on by default.
  * The code for allowing/dissalowing attributes has moved from the model to controller in this version. So each controller can manage it's own list of whitelisted attributes.
  * How to use ?
    * Tell params which parameter is to be whitelisted(allowed).
    * `permit` method is used for marking attributes available for mass assignment.
    * By default all values in the params hash are unavaible.
    * `require` method makes the attribute to be passed compulsorily for the record to be saved.
    * eg - `params.require(:subject).permit(:name, :position, :visible)` means it requires the subject key to be there and return the hashed value of subject and permit the mentioned attributes from the hash value.
    * Any other parameters which are not permitted will still be usable as values but wont be mass assigned to an object.
  
---

Now solution our error ForbiddenAttributesError` on the line `    @subject = Subject.new(params[:subject])` in subjects_controller.rb

1. Used `    params.require(:subject).permit(:name, :position, :visible)` for the parameter in the new method.
2. But to use it again for different action methods, created a private method and wrote that into a new method and passed that method into `new`.
3. Now will get a permitted version which is ready for mass assignment.
4. Done !! It's working ! On submitting on adding the subject.